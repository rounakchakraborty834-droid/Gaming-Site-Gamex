import{a as t,M as a,V as e,i,Q as n}from"./three.module.c9112413.js";function o(t,a,e,i,n,o=!1){return o&&(t=Math.min(Math.max(a,e),Math.max(Math.min(a,e),t))),(t-a)/(e-a)*(n-i)+i}const s=new t(0,0,.5),h=new t,r=(t,e,i)=>{const n=a.degToRad(e.fov);i=i||s.sub(e.position).normalize();const o=(t-e.position.z)/i.z,h=2*Math.tan(n/2)*o;return[h*e.aspect,h]},m=(t,a,{width:e,height:i})=>{const n=.5*e,o=.5*i,s=h;return t.updateMatrixWorld(),s.setFromMatrixPosition(t.matrixWorld),s.project(a),s.x=s.x*n,s.y=s.y*o,[s.x,s.y]},p=new t;new e;const c=new n,l=new n,u=new t(0,1,0);function d(a,{enabled:e=!0,vTarget:n=new t,spherical:o=new i,sphVelocity:s=new i,autoRotate:h=!1,autoRotateSpeed:r=1,rotateSpeed:m=.1,enableRotate:d=!0,enableZoom:M=!0,enablePan:x=!0,zoomSpeed:y=1,panSpeed:g=.1,zoomStyle:w="dolly",minPolarAngle:A=0,maxPolarAngle:P=Math.PI,minAzimuthAngle:f=-1/0,maxAzimuthAngle:z=1/0,minDistance:S=0,maxDistance:b=1/0}={}){this.enabled=e,this.spherical=o,this.sphVelocity=s,this.zoomStyle=w,this.minDistance=S,this.maxDistance=b,this.minAzimuthAngle=f,this.maxAzimuthAngle=z,this.minPolarAngle=A,this.maxPolarAngle=P;const I=new t,T=this.offset=new t;this.update=()=>{h&&function(){const t=2*Math.PI/60/60*r;this.sphVelocity.theta-=t}();const t=c.setFromUnitVectors(a.up,u),e=t.clone().invert(),i=p,m=l,d=2*Math.PI,M=a.position;T.copy(M).sub(n),T.applyQuaternion(t),o.setFromVector3(T),o.theta+=s.theta,o.phi+=s.phi,n.add(I);let x=f,y=z;isFinite(x)&&isFinite(y)&&(x<-Math.PI?x+=d:x>Math.PI&&(x-=d),y<-Math.PI?y+=d:y>Math.PI&&(y-=d),o.theta=x<=y?Math.max(x,Math.min(y,o.theta)):o.theta>(x+y)/2?Math.max(x,o.theta):Math.min(y,o.theta)),o.phi=Math.max(A,Math.min(P,o.phi)),o.makeSafe(),o.radius=Math.max(S,Math.min(b,o.radius)),T.setFromSpherical(o),T.applyQuaternion(e),M.copy(n).add(T),a.lookAt(n);const g=1e-6;(i.distanceToSquared(a.position)>g||8*(1-m.dot(a.quaternion))>g)&&(i.copy(a.position),m.copy(a.quaternion))},this.forcePosition=()=>{T.copy(a.position).sub(n),o.radius=sphericalTarget.radius=T.distance(),o.theta=sphericalTarget.theta=Math.atan2(T.x,T.z),o.phi=sphericalTarget.phi=Math.acos(Math.min(Math.max(T.y/sphericalTarget.radius,-1),1)),a.lookAt(n)}}function M(t,a,e){return(1-e)*t+e*a}function x(t,a,e,i){return M(t,a,1-Math.exp(-e*i))}export{d as O,m as a,x as d,M as l,o as m,r as w};
